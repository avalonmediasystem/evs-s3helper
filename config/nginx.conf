worker_processes  auto;
worker_rlimit_nofile 131072;

events {
    worker_connections 8192;
}

http {
    include mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
    '$status $body_bytes_sent "$http_referer" '
    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /dev/stdout  main;
    error_log   stderr debug;

    sendfile on;
    tcp_nopush on;
    keepalive_timeout 65;
    gzip on;

    upstream vod_s3 {
        server s3helper:8001;
    }

    map $sent_http_content_type $type_cache_expires {
        "video/MP2T" "1y";
        "application/octet-stream" "1y";
        "application/vnd.apple.mpegurl" "5m";
        "application/dash+xml" "5m";
        "video/mpd" "5m";
        "image/bif" "48h";
        "text/plain" "30d";
        "text/xml" "30d";
        "text/vtt" "30d";
        "image/jpeg" "48h";
        "application/xml" "24h";
        "application/json" "5m";
        default "5m";
    }

    map $http_cloudfront_forwarded_proto $proto {
        "https"  "https";
        "http"   "http";
        default  "https";
    }

    # CloudFront VOD token config
    #secure_token_cloudfront $cftoken {
    #    private_key_file /srv/vod/conf/cf_key.pem;
    #    key_pair_id {{cf_key_id}};
    #    acl "${proto}://${http_host}${secure_token_baseuri_comma}*";
    #}

    # Akamai token config:
    #secure_token_akamai $aktoken {
    #    key {{ak_private_key}};
    #    param_name t;
    #    acl "${secure_token_baseuri_comma}*";
    #}

    #map $http_host $token {
    #    "a-vrv.akamaized.net" $aktoken;
    #    "vrv.akamaized.net" $aktoken;
    #    default             $cftoken;
    #}

    server {
        set $g_edge 'localhost';
        set $g_secret 'secret';
        set $g_status '200';
        listen 80;
        server_name "$g_edge";
        #resolver {{dns_server}} valid=30s;

        # Common proxy settings
        proxy_http_version 1.1;
        proxy_buffering off;
        proxy_intercept_errors on;
        aio on;

        # Set the token via token type map:
        #secure_token $token;

        # Common VOD token config
        #secure_token_avoid_cookies on;
        #secure_token_expires_time 31d;
        #secure_token_query_token_expires_time 31d;

        # Common VOD settings
        vod_mode remote;
        vod_initial_read_size 32k;
        vod_cache_buffer_size 256k;
        #vod_secret_key "secret";
        #vod_base_url "${proto}://${http_host}";
        #vod_segments_base_url "${proto}://${http_host}";
        vod_upstream_location /__proxy__;
        vod_performance_counters on;
        vod_segment_duration 10000;
        vod_align_segments_to_key_frames on;
        vod_manifest_segment_durations_mode accurate;
        vod_segment_count_policy last_short;

        # Common headers and settings for all locations
        gzip_types application/vnd.apple.mpegurl video/mpd application/xml application/json text/plain application/dash+xml;
        add_header Access-Control-Allow-Headers "*";
        add_header Access-Control-Expose-Headers "Server,Range,Content-Length,Content-Range";
        add_header Access-Control-Allow-Methods "GET, HEAD";
        add_header Access-Control-Allow-Origin "*";
        expires $type_cache_expires;

        # Legacy non-versioned URLs: rewrite to version=0.  This is
        # done in a location so we cache under the legacy name.
        location ~ ^/evs/assets/ {
            rewrite "^/evs/assets/(.*)$" "/evs/0/assets/$1" last;
            rewrite "^/evs/assets/(.*)/(.*)$" "/evs/0/assets/$1/$2" last;
        }

        # MP4s and Subtitles - this is only used internally
        location ~ ^/evs/(?<v>[a-z0-9]+)/assets/(?<video>[a-z0-9]+)_(?<encode_id>[0-9a-zA-Z_-]+)\.(?<ext>mp4)$ {
            internal;
            set $url_path "${video}/${encode_id}.${ext}";
            rewrite .* /${url_path} break;
            proxy_pass http://s3helper:8001/${url_path};
        }

        location = /crossdomain.xml {
            #if ($http_x_cloudfront_secret != "$g_secret") {
            #    return 403;
            #}
            proxy_pass http://s3helper:8001/crossdomain.xml;
        }

        # BIFs
        location ~ ^/evs/(?<v>[a-z0-9]+)/assets/(?<video>[a-z0-9]+)_(?<bif_id>[0-9a-zA-Z_-]+)\.bif$ {
            #if ($http_x_cloudfront_secret != "$g_secret") {
            #    return 403;
            #}
            set $url_path "${video}/${bif_id}.bif";
            rewrite .* /${url_path} break;
            proxy_pass http://s3helper:8001/${url_path};
        }

        # Subtitles request support
        location ~ ^/evs/(?<v>[a-z0-9]+)/assets/(?<video>[a-z0-9]+)_(?<subtitle_id>[a-zA-Z0-9_-]+)\.(?<ext>txt|ass|ssa|srt)$ {
            #if ($http_x_cloudfront_secret != "$g_secret") {
            #    return 403;
            #}
            set $url_path "${video}/${subtitle_id}.${ext}";
            rewrite .* /${url_path} break;
            proxy_pass http://s3helper:8001/${url_path};
            add_header Content-Type text/plain;
            add_header Access-Control-Allow-Headers "*";
            add_header Access-Control-Expose-Headers "Server,Range,Content-Length,Content-Range";
            add_header Access-Control-Allow-Methods "GET, HEAD";
            add_header Access-Control-Allow-Origin "*";
        }

        # Screenshots
        location ~ ^/evs/(?<v>[a-z0-9]+)/assets/(?<video>[a-z0-9]+)_(?<frame>[0-9a-zA-Z_-]+)\.(?<ext>jpg|jpeg|png)$ {
            #if ($http_x_cloudfront_secret != "$g_secret") {
            #    return 403;
            #}
            set $url_path "${video}/${frame}.${ext}";
            rewrite .* /${url_path} break;
            proxy_pass http://s3helper:8001/${url_path};
        }

        # Internal proxy location
        location ~ ^/__proxy__/evs/(?<v>[a-z0-9]+)/assets/(?<video>[a-z0-9]+)_(?<encode_id>[0-9a-zA-Z_-]+)\.(?<format>[0-9a-zA-Z]+)$ {
            internal;
            proxy_pass http://s3helper:8001/${video}/${encode_id}.${format};
        }

        # Internal proxy location, unversioned
        location ~ ^/__proxy__/evs/assets/(?<video>[a-z0-9]+)_(?<encode_id>[0-9a-zA-Z_-]+)\.(?<format>[0-9a-zA-Z]+)$ {
            internal;
            proxy_pass http://s3helper:8001/${video}/${encode_id}.${format};
        }

        # HLS without DRM
        location ~ ^/evs/(?<v>[a-z0-9]+)/assets/[a-z0-9]+_([0-9a-zA-Z_-]+\.(mp4|srt)|(,[0-9a-zA-Z_-]+\.(mp4|srt))+,\.urlset)/(master|index|seg|encryption)(-[a-z0-9]+)*\.(m3u8|ts|key|vtt)$ {
            #if ($http_x_cloudfront_secret != "$g_secret") {
            #    return 403;
            #}

            rewrite "^/evs/0/assets/(.*)$" "/evs/assets/$1" break;

            vod hls;
            vod_metadata_cache moov_cache_hls 512m;
            vod_response_cache response_cache_hls 256m;
            vod_bootstrap_segment_durations 5000;
            vod_bootstrap_segment_durations 5000;
            #vod_hls_encryption_method "aes-128";
            #secure_token_types application/vnd.apple.mpegurl;
        }

        # MPEG-DASH without DRM
        location ~ ^/evs/(?<v>[a-z0-9]+)/assets/[a-z0-9]+_([0-9a-zA-Z_-]+\.mp4|(,[0-9a-zA-Z_-]+\.mp4)+,\.urlset)/(manifest|fragment|init)(-[a-z0-9]+)*\.(mpd|m4s|mp4)$ {
            #if ($http_x_cloudfront_secret != "$g_secret") {
            #    return 403;
            #}

            vod dash;
            vod_dash_profiles "urn:mpeg:dash:profile:full:2011";
            vod_dash_absolute_manifest_urls off;
            vod_metadata_cache moov_cache_dash 512m;
            vod_response_cache response_cache_dash 256m;
            vod_bootstrap_segment_durations 2500;
            vod_bootstrap_segment_durations 5000;
            vod_bootstrap_segment_durations 5000;
            #secure_token_types application/dash+xml video/mpd;
        }

        # Generic catch-all where a /evs location didn't match any
        # valid regexp.  Invalid request.
        location ~ ^/evs/ {
             return 302;
        }

        # ELB health check
        location = /_health {
            vod_status;
            vod_secret_key "$g_status";
        }

        # Status check for newrelic agent
        #location /stub_status {
        #    allow 127.0.0.1;
        #    deny all;
        #    stub_status;
        #}

        # Disallow all other usage not enabled above.
        location / {
            deny all;
        }
    }
}